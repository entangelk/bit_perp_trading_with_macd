<!DOCTYPE html>
<html>

<head>
    <title>트레이딩 봇 로그 뷰어</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    
</head>

<body class="bg-gray-100">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6 text-gray-800">트레이딩 봇 로그 뷰어</h1>

        <!-- 트레이딩 분석 그래프 섹션 -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-indigo-700">트레이딩 분석</h2>
            <div class="relative" style="width: 100%; height: 400px;">
                <canvas id="tradingChart"></canvas>
            </div>
            <div class="mt-4 text-sm text-gray-600">
                최근 24시간 동안의 가격 변동과 트레이딩 신호를 표시합니다.
            </div>
        </div>

        <!-- 디스크 용량 정보 섹션 -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-purple-700">서버 디스크 상태</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-medium mb-2">시스템 디스크 (루트)</h3>
                    <div class="bg-gray-100 rounded-lg p-4">
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">전체 용량:</span>
                            <span class="font-medium">{{ disk_info.total }}</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">사용 중:</span>
                            <span class="font-medium">{{ disk_info.used }} ({{ disk_info.percent_used }})</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">여유 공간:</span>
                            <span class="font-medium">{{ disk_info.free }} ({{ disk_info.percent_free }})</span>
                        </div>

                        <!-- 디스크 사용량 프로그레스 바 -->
                        <div class="w-full bg-gray-300 rounded-full h-4 mt-2">
                            <div id="root-disk-bar" class="bg-blue-600 h-4 rounded-full"
                                data-percent="{{ disk_info.percent_used|replace('%', '') }}"></div>
                        </div>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-medium mb-2">로그 저장소</h3>
                    <div class="bg-gray-100 rounded-lg p-4">
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">전체 용량:</span>
                            <span class="font-medium">{{ log_disk_info.total }}</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">사용 중:</span>
                            <span class="font-medium">{{ log_disk_info.used }} ({{ log_disk_info.percent_used }})</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">여유 공간:</span>
                            <span class="font-medium">{{ log_disk_info.free }} ({{ log_disk_info.percent_free }})</span>
                        </div>

                        <!-- 디스크 사용량 프로그레스 바 -->
                        <div class="w-full bg-gray-300 rounded-full h-4 mt-2">
                            <div id="log-disk-bar" class="bg-green-600 h-4 rounded-full"
                                data-percent="{{ log_disk_info.percent_used|replace('%', '') }}"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 디스크 공간 경고 메시지 (90% 이상 사용 시) -->
            {% if disk_info.percent_used|float > 90 or log_disk_info.percent_used|float > 90 %}
            <div class="mt-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4" role="alert">
                <p class="font-bold">디스크 공간 경고!</p>
                <p>디스크 공간이 90% 이상 사용되었습니다. 불필요한 파일을 정리하는 것이 좋습니다.</p>
            </div>
            {% endif %}
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 text-blue-700">거래 실행 로그</h2>
                <p class="text-gray-600 mb-4">트레이딩 봇 실행 중에 생성된 로그를 확인합니다.</p>
                <div class="flex space-x-4">
                    <a href="/log/trading"
                        class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">
                        전체 로그 보기
                    </a>
                    <a href="/log/trading?error_only=true"
                        class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition">
                        에러만 보기
                    </a>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 text-green-700">백테스트 로그</h2>
                <p class="text-gray-600 mb-4">전략 백테스트 과정의 로그를 확인합니다.</p>
                <div class="flex space-x-4">
                    <a href="/log/backtest"
                        class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
                        전체 로그 보기
                    </a>
                    <a href="/log/backtest?error_only=true"
                        class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition">
                        에러만 보기
                    </a>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 text-purple-700">거래 통계</h2>
                <p class="text-gray-600 mb-4">바이비트 거래 승률 및 손익 통계를 확인합니다.</p>
                <div class="flex space-x-4">
                    <a href="/trading-stats"
                        class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition">
                        승률 통계 보기
                    </a>
                </div>
            </div>
        </div>

        <!-- 새로 추가된 전략 설정 카드 -->
        <div class="bg-white rounded-lg shadow p-6">
            <h2 class="text-xl font-semibold mb-4 text-indigo-700">전략 설정</h2>
            <p class="text-gray-600 mb-4">현재 사용 중인 트레이딩 전략의 매개변수를 확인합니다.</p>
            <div class="flex space-x-4">
                <a href="/strategy-config"
                    class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">
                    전략 설정 보기
                </a>
            </div>
        </div>
    </div>
    <!-- index.html 파일에 추가 -->
    <script id="trade-analysis-data" type="application/json">{{ trade_analysis_json | safe }}</script>
    <!-- 프로그레스 바 설정과 자동 새로고침을 위한 스크립트 -->
    <script>
        // 데이터 초기화 함수
        document.addEventListener('DOMContentLoaded', function () {
            // 기존 프로그레스 바 설정 (유지)
            var rootBar = document.getElementById('root-disk-bar');
            if (rootBar) {
                var rootPercent = rootBar.getAttribute('data-percent');
                rootBar.style.width = rootPercent + '%';
            }

            var logBar = document.getElementById('log-disk-bar');
            if (logBar) {
                var logPercent = logBar.getAttribute('data-percent');
                logBar.style.width = logPercent + '%';
            }
            
            // 차트 데이터 초기화
            try {
                console.log("차트 데이터 초기화 시작");
                
                // 중요: Jinja2 템플릿에서 전달된 데이터에 접근하는 올바른 방법
                // 템플릿 엔진에서 전달된 JSON 데이터 (문자열로 포함됨)
                let tradeAnalysisData;
                
                try {
                    // Jinja2 템플릿 내 변수를 직접 사용해야 함 (JavaScript 변수로 접근 불가)
                    // 여기서는 원본 코드 방식을 따름
                    if (typeof {{ trade_analysis_json | safe }} === 'object') {
                        tradeAnalysisData = {{ trade_analysis_json | safe }};
                    } else {
                        try {
                            tradeAnalysisData = JSON.parse({{ trade_analysis_json | safe }});
                        } catch (e) {
                            console.error("데이터 파싱 오류:", e);
                            tradeAnalysisData = { chart_data: [], strategy_signals: {}, position_timeline: [], position_ranges: [] };
                        }
                    }
                    
                    console.log("차트 데이터 파싱 성공:", tradeAnalysisData);
                } catch (e) {
                    console.error("데이터 접근 오류:", e);
                    tradeAnalysisData = { chart_data: [], strategy_signals: {}, position_timeline: [], position_ranges: [] };
                }
                
                // 차트 생성
                if (tradeAnalysisData && tradeAnalysisData.chart_data && tradeAnalysisData.chart_data.length > 0) {
                    createTradingChart(tradeAnalysisData);
                } else {
                    document.getElementById('tradingChart').innerHTML = '<div class="p-4 text-red-600">표시할 차트 데이터가 없습니다.</div>';
                }
            } catch (error) {
                console.error("차트 초기화 오류:", error);
                document.getElementById('tradingChart').innerHTML = '<div class="p-4 text-red-600">차트 생성 중 오류가 발생했습니다.</div>';
            }
        });

        // normalizeTimestamp 함수도 개선해보세요
        function normalizeTimestamp(timestamp) {
            if (!timestamp) return null;
            
            try {
                // 이미 Date 객체인 경우
                if (timestamp instanceof Date) return timestamp;
                
                // 숫자형 또는 숫자 문자열 타임스탬프
                if (typeof timestamp === 'number' || 
                    (typeof timestamp === 'string' && !isNaN(Number(timestamp)))) {
                    
                    const num = Number(timestamp);
                    
                    // 밀리초 단위 타임스탬프 (13자리 이상)가 미래 시간인지 확인
                    if (String(num).length >= 13) {
                        const date = new Date(num);
                        const now = new Date();
                        
                        // 미래 시간인 경우 초 단위로 변환 (밀리초/1000)
                        if (date.getFullYear() > 2030) {
                            console.warn("타임스탬프가 미래 시간으로 해석됨, 초 단위로 변환 시도:", timestamp);
                            return new Date(num / 1000);
                        }
                        
                        return date;
                    }
                    
                    // 초 단위 타임스탬프 (10자리) - 밀리초로 변환
                    return new Date(num * 1000);
                }
                
                // ISO 형식 문자열 (예: '2025-05-02T02:00:00')
                return new Date(timestamp);
            } catch (e) {
                console.error("타임스탬프 변환 오류:", e, timestamp);
                return new Date(); // 오류 시 현재 시간 반환
            }
        }
        // 어노테이션 통합 처리 함수
        function generateAnnotations(data) {
            const annotations = {};

            // 포지션 타임라인 어노테이션 추가
            if (data.position_timeline && Array.isArray(data.position_timeline)) {
                console.log("포지션 타임라인 처리:", data.position_timeline);

                data.position_timeline.forEach((item, index) => {
                    try {
                        if (!item.position || !item.timestamp) {
                            console.warn("포지션 정보 누락:", item);
                            return;
                        }

                        const color = item.position === 'Short' ? 'rgba(255, 99, 132, 1)' : 'rgba(75, 192, 192, 1)';
                        const timestamp = normalizeTimestamp(item.timestamp);

                        console.log(`포지션 ${item.position} 타임스탬프:`, item.timestamp, "→ 변환:", timestamp);

                        if (!timestamp) {
                            console.warn("타임스탬프 변환 실패:", item.timestamp);
                            return;
                        }

                        annotations[`timeline-${index}`] = {
                            type: 'line',
                            scaleID: 'x',
                            value: timestamp,
                            borderColor: color,
                            borderWidth: 2,
                            label: {
                                content: item.position,
                                enabled: true,
                                position: 'top',
                                backgroundColor: color
                            }
                        };
                        console.log(`어노테이션 생성 성공: timeline-${index}`);
                    } catch (e) {
                        console.error('타임라인 어노테이션 생성 오류:', e, item);
                    }
                });
            } else {
                console.log("포지션 타임라인 데이터 없음");
            }

            // 포지션 범위 어노테이션 추가
            if (data.position_ranges && Array.isArray(data.position_ranges)) {
                console.log("포지션 범위 처리:", data.position_ranges);

                data.position_ranges.forEach((range, index) => {
                    try {
                        if (!range.position || !range.start || !range.end) {
                            console.warn("범위 정보 누락:", range);
                            return;
                        }

                        const bgColor = range.position === 'Short' ? 'rgba(255, 99, 132, 0.1)' : 'rgba(75, 192, 192, 0.1)';
                        const borderColor = range.position === 'Short' ? 'rgba(255, 99, 132, 0.5)' : 'rgba(75, 192, 192, 0.5)';

                        const start = normalizeTimestamp(range.start);
                        const end = normalizeTimestamp(range.end);

                        console.log(`범위 ${range.position} 시작:`, range.start, "→ 변환:", start);
                        console.log(`범위 ${range.position} 종료:`, range.end, "→ 변환:", end);

                        if (!start || !end) {
                            console.warn("범위 타임스탬프 변환 실패:", range);
                            return;
                        }

                        annotations[`range-${index}`] = {
                            type: 'box',
                            xMin: start,
                            xMax: end,
                            yMin: 'min',
                            yMax: 'max',
                            backgroundColor: bgColor,
                            borderColor: borderColor,
                            borderWidth: 1
                        };
                        console.log(`어노테이션 생성 성공: range-${index}`);
                    } catch (e) {
                        console.error('범위 어노테이션 생성 오류:', e, range);
                    }
                });
            } else {
                console.log("포지션 범위 데이터 없음");
            }

            console.log("생성된 어노테이션:", Object.keys(annotations).length);
            return annotations;
        }

        // 개선된 차트 생성 함수
        function createTradingChart(data) {
            console.log("차트 생성 시작");

            // 차트 캔버스 컨텍스트 가져오기
            const ctx = document.getElementById('tradingChart').getContext('2d');
            if (!ctx) {
                console.error("차트 캔버스를 찾을 수 없습니다");
                return;
            }

            // 데이터 유효성 검사
            if (!data.chart_data || !Array.isArray(data.chart_data) || data.chart_data.length === 0) {
                console.error("유효한 차트 데이터가 없습니다");
                return;
            }

            try {
                console.log("차트 데이터 처리 중...");

            // 차트 데이터 처리
            const chartData = data.chart_data.map(item => {
                    // 타임스탬프 변환 (ISO 문자열 → Date 객체)
                    const timestamp = normalizeTimestamp(item.timestamp);
                    
                    return {
                        timestamp: timestamp,
                        x: timestamp, // Chart.js용 x 좌표
                        open: Number(item.open) || 0,
                        high: Number(item.high) || 0,
                        low: Number(item.low) || 0,
                        close: Number(item.close) || 0,
                        volume: Number(item.volume) || 0
                    };
                }).filter(item => item.timestamp); // 유효한 타임스탬프만 유지
                
                // 차트 데이터의 시간 범위 확인
                if (chartData.length > 0) {
                    const firstTimestamp = chartData[0].timestamp;
                    const lastTimestamp = chartData[chartData.length - 1].timestamp;
                    
                    console.log("차트 데이터 첫 시간:", new Date(firstTimestamp).toISOString());
                    console.log("차트 데이터 마지막 시간:", new Date(lastTimestamp).toISOString());
                    
                    // 어노테이션 타임스탬프 확인
                    if (data.position_timeline && data.position_timeline.length > 0) {
                        const annotationTime = normalizeTimestamp(data.position_timeline[0].timestamp);
                        console.log("어노테이션 시간:", annotationTime.toISOString());
                        
                        // 밀리초 타임스탬프가 실제 시간보다 미래에 있는지 확인
                        const now = new Date();
                        if (annotationTime > now) {
                            console.warn("어노테이션 타임스탬프가 현재 시간보다 미래에 있습니다!");
                            console.warn("현재 시간:", now.toISOString());
                            
                            // 밀리초 대신 초 단위로 처리해보기 (1000으로 나눔)
                            const correctedTime = new Date(annotationTime.getTime() / 1000);
                            console.log("보정된 시간:", correctedTime.toISOString());
                            
                            // 보정된 시간이 차트 범위 내에 있는지 확인
                            if (correctedTime >= firstTimestamp && correctedTime <= lastTimestamp) {
                                console.log("보정된 시간이 차트 범위 내에 있습니다!");
                                
                                // 어노테이션 시간 업데이트
                                if (annotations['timeline-0']) {
                                    annotations['timeline-0'].value = correctedTime;
                                }
                            }
                        }
                    }
                }
                console.log(`데이터 처리 완료: ${chartData.length}개 항목`);

                // 시간 순서대로 정렬
                chartData.sort((a, b) => a.timestamp - b.timestamp);

                // 데이터에서 최소/최대 가격 찾기 (Y축 범위 설정을 위해)
                let minPrice = Math.min(...chartData.map(item => item.low));
                let maxPrice = Math.max(...chartData.map(item => item.high));

                // Y축 범위 설정 (10% 여유)
                const range = maxPrice - minPrice;
                const padding = range * 0.1;
                const yAxisMin = Math.floor(minPrice - padding);
                const yAxisMax = Math.ceil(maxPrice + padding);

                console.log(`데이터 가격 범위: $${minPrice.toFixed(2)} ~ $${maxPrice.toFixed(2)}`);
                console.log(`Y축 범위: $${yAxisMin.toFixed(2)} ~ $${yAxisMax.toFixed(2)}`);

                // 라인 차트 데이터셋
                const lineDataset = {
                    label: '비트코인',
                    data: chartData.map(item => ({
                        x: item.timestamp,
                        y: item.close,
                        _open: item.open,
                        _high: item.high,
                        _low: item.low,
                        _close: item.close,
                        _volume: item.volume
                    })),
                    borderColor: 'rgb(75, 192, 192)',
                    backgroundColor: 'rgba(75, 192, 192, 0.5)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1, // 약간의 곡선 효과
                    pointRadius: 0, // 포인트 표시 없음
                    pointHoverRadius: 5, // 마우스 오버 시에만 포인트 표시
                    pointHoverBackgroundColor: 'rgb(75, 192, 192)',
                    pointHoverBorderColor: 'white',
                    pointHoverBorderWidth: 2
                };

                // 어노테이션 생성
                const annotations = generateAnnotations(data);

                // 차트 생성 옵션
                const chartConfig = {
                    type: 'line',
                    data: {
                        datasets: [lineDataset]
                    },
                    options: {
                        animation: false, // 애니메이션 끄기 (성능 향상)
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: function (context) {
                                        const item = context.raw;
                                        if (item && item._open !== undefined) {
                                            return [
                                                `시가: $${item._open.toFixed(2)}`,
                                                `고가: $${item._high.toFixed(2)}`,
                                                `저가: $${item._low.toFixed(2)}`,
                                                `종가: $${item._close.toFixed(2)}`
                                            ];
                                        }
                                        return context.dataset.label;
                                    },
                                    // 툴팁에 표시되는 시간을 KST로 변환
                                    title: function (context) {
                                        if (context[0] && context[0].label) {
                                            // ISO 문자열로 변환
                                            let dateStr;
                                            try {
                                                const date = new Date(context[0].label);
                                                // UTC 시간에 9시간 추가
                                                date.setHours(date.getHours() + 9);
                                                // 원하는 형식으로 포맷팅 (YYYY-MM-DD HH:MM)
                                                dateStr = date.toISOString().replace('T', ' ').substring(0, 16) + ' (KST)';
                                            } catch (e) {
                                                dateStr = context[0].label + ' (변환 실패)';
                                            }
                                            return dateStr;
                                        }
                                        return '';
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: '비트코인 가격 및 트레이딩 신호 (24시간)'
                            },
                            annotation: {
                                annotations: annotations
                            }
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    unit: 'hour',
                                    displayFormats: {
                                        hour: 'HH:mm'
                                    },
                                    // KST 시간대 표시를 위한 설정
                                    parser: function (utcTime) {
                                        try {
                                            const date = new Date(utcTime);
                                            // UTC 시간에 9시간 추가 (KST)
                                            date.setHours(date.getHours() + 9);
                                            return date;
                                        } catch (e) {
                                            console.error("시간 파싱 오류:", e, utcTime);
                                            return new Date();
                                        }
                                    },
                                    tooltipFormat: 'yyyy-MM-dd HH:mm (KST)'
                                },
                                title: {
                                    display: true,
                                    text: '시간 (KST)'
                                },
                                grid: {
                                    display: false
                                }
                            },
                            y: {
                                min: yAxisMin,
                                max: yAxisMax,
                                title: {
                                    display: true,
                                    text: '가격 (USDT)'
                                },
                                ticks: {
                                    callback: function (value) {
                                        return '$' + value.toFixed(0);
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        }
                    }
                };

                // 차트 생성
                console.log("차트 렌더링 시작");
                const chart = new Chart(ctx, chartConfig);
                console.log("차트 렌더링 완료");

                return chart;
            } catch (error) {
                console.error("차트 생성 중 오류 발생:", error);
                document.getElementById('tradingChart').innerHTML =
                    `<div class="p-4 text-red-600">차트 생성 오류: ${error.message}</div>`;
            }
        }
        // 신호와 가장 가까운 차트 데이터 찾기
        function findClosestPrice(chartData, timestamp) {
            const signalTime = new Date(timestamp).getTime();
            let closestData = null;
            let minDiff = Infinity;

            for (const item of chartData) {
                const itemTime = new Date(item.timestamp).getTime();
                const diff = Math.abs(itemTime - signalTime);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestData = item;
                }
            }

            return closestData ? closestData.close : null;
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
</body>

</html>