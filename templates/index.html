<!DOCTYPE html>
<html>

<head>
    <title>트레이딩 봇 로그 뷰어</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
</head>

<body class="bg-gray-100">
    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-6 text-gray-800">트레이딩 봇 로그 뷰어</h1>

        <!-- 트레이딩 분석 그래프 섹션 -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-indigo-700">트레이딩 분석</h2>
            <div class="relative" style="width: 100%; height: 400px;">
                <canvas id="tradingChart"></canvas>
            </div>
            <div class="mt-4 text-sm text-gray-600">
                최근 24시간 동안의 가격 변동과 트레이딩 신호를 표시합니다.
            </div>
        </div>

        <!-- 디스크 용량 정보 섹션 -->
        <div class="bg-white rounded-lg shadow p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4 text-purple-700">서버 디스크 상태</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <h3 class="text-lg font-medium mb-2">시스템 디스크 (루트)</h3>
                    <div class="bg-gray-100 rounded-lg p-4">
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">전체 용량:</span>
                            <span class="font-medium">{{ disk_info.total }}</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">사용 중:</span>
                            <span class="font-medium">{{ disk_info.used }} ({{ disk_info.percent_used }})</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">여유 공간:</span>
                            <span class="font-medium">{{ disk_info.free }} ({{ disk_info.percent_free }})</span>
                        </div>

                        <!-- 디스크 사용량 프로그레스 바 -->
                        <div class="w-full bg-gray-300 rounded-full h-4 mt-2">
                            <div id="root-disk-bar" class="bg-blue-600 h-4 rounded-full"
                                data-percent="{{ disk_info.percent_used|replace('%', '') }}"></div>
                        </div>
                    </div>
                </div>

                <div>
                    <h3 class="text-lg font-medium mb-2">로그 저장소</h3>
                    <div class="bg-gray-100 rounded-lg p-4">
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">전체 용량:</span>
                            <span class="font-medium">{{ log_disk_info.total }}</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">사용 중:</span>
                            <span class="font-medium">{{ log_disk_info.used }} ({{ log_disk_info.percent_used }})</span>
                        </div>
                        <div class="flex justify-between mb-2">
                            <span class="text-gray-700">여유 공간:</span>
                            <span class="font-medium">{{ log_disk_info.free }} ({{ log_disk_info.percent_free }})</span>
                        </div>

                        <!-- 디스크 사용량 프로그레스 바 -->
                        <div class="w-full bg-gray-300 rounded-full h-4 mt-2">
                            <div id="log-disk-bar" class="bg-green-600 h-4 rounded-full"
                                data-percent="{{ log_disk_info.percent_used|replace('%', '') }}"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 디스크 공간 경고 메시지 (90% 이상 사용 시) -->
            {% if disk_info.percent_used|float > 90 or log_disk_info.percent_used|float > 90 %}
            <div class="mt-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4" role="alert">
                <p class="font-bold">디스크 공간 경고!</p>
                <p>디스크 공간이 90% 이상 사용되었습니다. 불필요한 파일을 정리하는 것이 좋습니다.</p>
            </div>
            {% endif %}
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 text-blue-700">거래 실행 로그</h2>
                <p class="text-gray-600 mb-4">트레이딩 봇 실행 중에 생성된 로그를 확인합니다.</p>
                <div class="flex space-x-4">
                    <a href="/log/trading"
                        class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition">
                        전체 로그 보기
                    </a>
                    <a href="/log/trading?error_only=true"
                        class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition">
                        에러만 보기
                    </a>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 text-green-700">백테스트 로그</h2>
                <p class="text-gray-600 mb-4">전략 백테스트 과정의 로그를 확인합니다.</p>
                <div class="flex space-x-4">
                    <a href="/log/backtest"
                        class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition">
                        전체 로그 보기
                    </a>
                    <a href="/log/backtest?error_only=true"
                        class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition">
                        에러만 보기
                    </a>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h2 class="text-xl font-semibold mb-4 text-purple-700">거래 통계</h2>
                <p class="text-gray-600 mb-4">바이비트 거래 승률 및 손익 통계를 확인합니다.</p>
                <div class="flex space-x-4">
                    <a href="/trading-stats"
                        class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition">
                        승률 통계 보기
                    </a>
                </div>
            </div>
        </div>

        <!-- 새로 추가된 전략 설정 카드 -->
    <div class="bg-white rounded-lg shadow p-6">
        <h2 class="text-xl font-semibold mb-4 text-indigo-700">전략 설정</h2>
        <p class="text-gray-600 mb-4">현재 사용 중인 트레이딩 전략의 매개변수를 확인합니다.</p>
        <div class="flex space-x-4">
            <a href="/strategy-config" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 transition">
                전략 설정 보기
            </a>
        </div>
    </div>
</div>

    <!-- 프로그레스 바 설정과 자동 새로고침을 위한 스크립트 -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // 기존 프로그레스 바 설정
            var rootBar = document.getElementById('root-disk-bar');
            if (rootBar) {
                var rootPercent = rootBar.getAttribute('data-percent');
                rootBar.style.width = rootPercent + '%';
            }

            var logBar = document.getElementById('log-disk-bar');
            if (logBar) {
                var logPercent = logBar.getAttribute('data-percent');
                logBar.style.width = logPercent + '%';
            }

            try {
            // 서버에서 전달받은 트레이딩 분석 데이터를 파싱
            let tradeAnalysisData;
            
            // 이미 JavaScript 객체인지 확인
            if (typeof {{ trade_analysis_json | safe }} === 'object') {
                tradeAnalysisData = {{ trade_analysis_json | safe }};
            } else {
                // 문자열이라면 파싱
                try {
                    tradeAnalysisData = JSON.parse({{ trade_analysis_json | safe }});
                } catch (e) {
                    console.error("데이터 파싱 오류:", e);
                    tradeAnalysisData = { chart_data: [], strategy_signals: {}, position_timeline: [], position_ranges: [] };
                }
            }
            
            // 차트 생성
            if (tradeAnalysisData && tradeAnalysisData.chart_data && tradeAnalysisData.chart_data.length > 0) {
                createTradingChart(tradeAnalysisData);
            } else {
                document.getElementById('tradingChart').innerHTML = '<div class="p-4 text-red-600">표시할 차트 데이터가 없습니다.</div>';
            }
        } catch (error) {
            console.error("차트 생성 오류:", error);
            document.getElementById('tradingChart').innerHTML = '<div class="p-4 text-red-600">차트 생성 중 오류가 발생했습니다.</div>';
        }
        });


        // 트레이딩 차트 생성 함수 - 표준 캔들스틱 차트 구현
        function createTradingChart(data) {
            // 차트 캔버스 컨텍스트 가져오기
            const ctx = document.getElementById('tradingChart').getContext('2d');
            
            // 시간 순서대로 정렬
            data.chart_data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // 데이터에서 최소/최대 가격 찾기 (Y축 범위 설정을 위해)
            let minPrice = Infinity;
            let maxPrice = -Infinity;
            
            data.chart_data.forEach(item => {
                minPrice = Math.min(minPrice, item.low);
                maxPrice = Math.max(maxPrice, item.high);
            });
            
            // 범위에 약간의 여유 추가 (데이터의 약 1% 정도)
            const padding = (maxPrice - minPrice) * 0.01;
            const yAxisMin = Math.floor(minPrice - padding);
            const yAxisMax = Math.ceil(maxPrice + padding);
            
            console.log(`차트 Y축 범위 설정: $${yAxisMin} ~ $${yAxisMax}`);
            
            // 신호와 가장 가까운 차트 데이터 찾기 (내부 함수)
            function findClosestPrice(chartData, timestamp) {
                const signalTime = new Date(timestamp).getTime();
                let closestData = null;
                let minDiff = Infinity;
                
                for (const item of chartData) {
                    const itemTime = new Date(item.timestamp).getTime();
                    const diff = Math.abs(itemTime - signalTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestData = item;
                    }
                }
                
                return closestData ? closestData.close : null;
            }
            
            // 캔들스틱 차트 데이터 준비
            // 하나의 통합된 데이터셋으로 표준 캔들스틱을 표현합니다
            const ohlcData = data.chart_data.map(item => {
                return {
                    x: new Date(item.timestamp),
                    o: item.open,
                    h: item.high,
                    l: item.low,
                    c: item.close
                };
            });

            // Chart.js에서 커스텀 캔들스틱 차트 구현
            Chart.defaults.elements.candlestick = {
                color: {
                    up: 'rgba(0, 255, 0, 1)',
                    down: 'rgba(255, 0, 0, 1)',
                    unchanged: '#999',
                },
            };

            // 커스텀 캔들스틱 차트 엘리먼트 등록
            class CandlestickElement extends Chart.Element {
                draw(ctx) {
                    const { x, o, h, l, c } = this.getProps(['x', 'o', 'h', 'l', 'c']);
                    const { width } = this.getProps(['width']);
                    
                    // 캔들 상승/하락 여부 결정
                    const isUp = c >= o;
                    
                    // 색상 설정
                    const color = isUp ? 'rgba(0, 255, 0, 1)' : 'rgba(255, 0, 0, 1)';
                    const bodyColor = isUp ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                    
                    // 캔들 몸통 좌표 계산
                    const xCenter = x;
                    const yOpen = this.getProps(['y'])[isUp ? 'o' : 'c'];
                    const yClose = this.getProps(['y'])[isUp ? 'c' : 'o'];
                    const bodyHeight = Math.abs(yOpen - yClose);
                    
                    // 윅(wick) 좌표
                    const yHigh = this.getProps(['y']).h;
                    const yLow = this.getProps(['y']).l;
                    
                    // 캔들 너비 (차트 크기에 비례)
                    const candleWidth = width * 0.7; // 캔들 너비 조정
                    
                    // 윅(wick) 그리기 (고가-저가 선)
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.moveTo(xCenter, yHigh);
                    ctx.lineTo(xCenter, yLow);
                    ctx.stroke();
                    
                    // 캔들 몸통 그리기
                    ctx.fillStyle = bodyColor;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.fillRect(xCenter - candleWidth / 2, yOpen, candleWidth, bodyHeight);
                    ctx.strokeRect(xCenter - candleWidth / 2, yOpen, candleWidth, bodyHeight);
                }
            }

            // 커스텀 캔들스틱 컨트롤러 등록
            class CandlestickController extends Chart.DatasetController {
                static id = 'candlestick';
                static defaults = {};
                static overrides = {
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                }
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'right',
                        }
                    }
                };
                
                linkScales() {
                    const dataset = this.getDataset();
                    const meta = this._cachedMeta;
                    
                    meta.xScale = this.getScaleForId(meta.xAxisID || 'x');
                    meta.yScale = this.getScaleForId(meta.yAxisID || 'y');
                }
                
                getElements() {
                    return this._cachedMeta.data;
                }
                
                // 데이터 구성 업데이트
                update(mode) {
                    const meta = this._cachedMeta;
                    const data = meta.data || [];
                    const dataset = this.getDataset();
                    
                    this.updateElements(data, 0, data.length, mode);
                }
                
                updateElements(elements, start, count, mode) {
                    const dataset = this.getDataset();
                    const meta = this._cachedMeta;
                    const xScale = meta.xScale;
                    const yScale = meta.yScale;
                    
                    const firstOHLC = dataset.data[start];
                    const last = start + count - 1;
                    const lastOHLC = dataset.data[last];
                    
                    const barWidth = this._calculateBarWidth(xScale, start, count);
                    
                    for (let i = start; i < start + count; i++) {
                        const ohlc = dataset.data[i];
                        const properties = {
                            x: xScale.getPixelForValue(ohlc.x),
                            o: yScale.getPixelForValue(ohlc.o),
                            h: yScale.getPixelForValue(ohlc.h),
                            l: yScale.getPixelForValue(ohlc.l),
                            c: yScale.getPixelForValue(ohlc.c),
                            width: barWidth,
                        };
                        
                        const element = elements[i];
                        if (element) {
                            element.x = properties.x;
                            element.o = properties.o;
                            element.h = properties.h;
                            element.l = properties.l;
                            element.c = properties.c;
                            element.width = properties.width;
                        } else {
                            meta.data[i] = new CandlestickElement({
                                x: properties.x,
                                o: properties.o,
                                h: properties.h,
                                l: properties.l,
                                c: properties.c,
                                width: properties.width,
                            });
                        }
                    }
                }
                
                _calculateBarWidth(scale, start, count) {
                    const dataset = this.getDataset();
                    
                    if (count === 1) {
                        return 20; // 단일 데이터 포인트의 경우
                    }
                    
                    // 두 포인트 사이의 너비 계산
                    const firstDate = new Date(dataset.data[start].x);
                    const secondDate = new Date(dataset.data[start + 1].x);
                    const firstPixel = scale.getPixelForValue(firstDate);
                    const secondPixel = scale.getPixelForValue(secondDate);
                    
                    // 적절한 바 너비 계산 (간격의 약 70%)
                    return Math.abs(firstPixel - secondPixel) * 0.7;
                }
                
                // 툴팁을 위한 데이터셋 요소 가져오기
                getLabelAndValue(index) {
                    const me = this;
                    const meta = me._cachedMeta;
                    const {xScale, yScale} = meta;
                    const ohlc = me.getDataset().data[index];
                    const xLabel = xScale.getLabelForValue(ohlc.x);
                    
                    return {
                        label: xLabel,
                        value: `O: ${ohlc.o.toFixed(2)}, H: ${ohlc.h.toFixed(2)}, L: ${ohlc.l.toFixed(2)}, C: ${ohlc.c.toFixed(2)}`
                    };
                }
            }

            // 캔들스틱 컨트롤러 등록
            Chart.register(CandlestickController);
            Chart.register(CandlestickElement);
            
            // 차트 데이터 구성
            const chartData = {
                datasets: [
                    // 캔들스틱 데이터
                    {
                        label: '비트코인',
                        type: 'candlestick',
                        data: ohlcData
                    }
                ]
            };
            
            // 전략 신호 표시 (별도 데이터셋으로 추가)
            if (data.strategy_signals && Object.keys(data.strategy_signals).length > 0) {
                Object.entries(data.strategy_signals).forEach(([strategy, signals]) => {
                    // Long 신호 추가
                    const longSignals = signals.filter(signal => signal.position === 'Long');
                    if (longSignals.length > 0) {
                        chartData.datasets.push({
                            label: `${strategy} - Long`,
                            type: 'scatter',
                            data: longSignals.map(signal => ({
                                x: new Date(signal.timestamp),
                                y: signal.price || findClosestPrice(data.chart_data, signal.timestamp)
                            })),
                            borderColor: 'green',
                            backgroundColor: 'green',
                            pointStyle: 'triangle',
                            pointRadius: 8,
                            pointRotation: 0,
                            showLine: false
                        });
                    }
                    
                    // Short 신호 추가
                    const shortSignals = signals.filter(signal => signal.position === 'Short');
                    if (shortSignals.length > 0) {
                        chartData.datasets.push({
                            label: `${strategy} - Short`,
                            type: 'scatter',
                            data: shortSignals.map(signal => ({
                                x: new Date(signal.timestamp),
                                y: signal.price || findClosestPrice(data.chart_data, signal.timestamp)
                            })),
                            borderColor: 'red',
                            backgroundColor: 'red',
                            pointStyle: 'triangle',
                            pointRadius: 8,
                            pointRotation: 180,
                            showLine: false
                        });
                    }
                });
            }
            
            // 차트 생성
            const chart = new Chart(ctx, {
                type: 'candlestick',  // 기본 타입을 candlestick으로 설정
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                }
                            },
                            title: {
                                display: true,
                                text: '시간'
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '가격 (USDT)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            // Y축 범위 명시적 설정
                            min: yAxisMin,
                            max: yAxisMax
                        }
                    },
                    plugins: {
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                                modifierKey: 'ctrl',
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                            }
                        },
                        title: {
                            display: true,
                            text: '비트코인 가격 및 트레이딩 신호 (24시간)'
                        },
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.type === 'candlestick') {
                                        const dataPoint = ohlcData[context.dataIndex];
                                        return [
                                            `시가: $${dataPoint.o.toFixed(2)}`,
                                            `고가: $${dataPoint.h.toFixed(2)}`,
                                            `저가: $${dataPoint.l.toFixed(2)}`,
                                            `종가: $${dataPoint.c.toFixed(2)}`
                                        ];
                                    } else {
                                        return context.dataset.label;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            // 포지션 구간 배경색 추가
            if (data.position_ranges && data.position_ranges.length > 0) {
                // annotation 플러그인 확인 및 초기화
                if (!chart.options.plugins.annotation) {
                    chart.options.plugins.annotation = { annotations: {} };
                }
                
                data.position_ranges.forEach((range, index) => {
                    const color = range.position === 'Long' ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)';
                    chart.options.plugins.annotation.annotations[`range_${index}`] = {
                        type: 'box',
                        xMin: new Date(range.start),
                        xMax: new Date(range.end),
                        backgroundColor: color,
                        borderWidth: 0
                    };
                });
                
                chart.update();
            }

            // 리셋 버튼 추가
            const resetButton = document.createElement('button');
            resetButton.textContent = '차트 리셋';
            resetButton.className = 'px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700 text-sm mt-2';
            resetButton.onclick = function() {
                chart.resetZoom();
            };
            document.getElementById('tradingChart').parentNode.appendChild(resetButton);
        }
    // 신호와 가장 가까운 차트 데이터 찾기
    function findClosestPrice(chartData, timestamp) {
        const signalTime = new Date(timestamp).getTime();
        let closestData = null;
        let minDiff = Infinity;
        
        for (const item of chartData) {
            const itemTime = new Date(item.timestamp).getTime();
            const diff = Math.abs(itemTime - signalTime);
            if (diff < minDiff) {
                minDiff = diff;
                closestData = item;
            }
        }
        
        return closestData ? closestData.close : null;
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
</body>

</html>