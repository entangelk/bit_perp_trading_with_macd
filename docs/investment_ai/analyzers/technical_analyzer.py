import json
import re
import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timezone, timedelta
from google import genai
from google.genai import types
import sys
import os
import ta
from scipy import stats

# ÏÉÅÏúÑ ÎîîÎ†âÌÜ†Î¶¨Ïùò Î™®Îìà importÎ•º ÏúÑÌïú Í≤ΩÎ°ú Ï∂îÍ∞Ä
sys.path.append(os.path.join(os.path.dirname(__file__), '../../../'))

from docs.investment_ai.config import CONFIG, API_KEY, MODEL_PRIORITY
from docs.investment_ai.indicators.technical_indicators import calculate_technical_indicators, get_latest_indicators

# üîß ÏÉàÎ°ú Ï∂îÍ∞Ä: ÎèôÏ†Å timeframe ÏÑ§Ï†ïÏùÑ ÏúÑÌïú import
from main_ai_new import TRADING_CONFIG, TIME_VALUES

# Î°úÍπÖ ÏÑ§Ï†ï
logger = logging.getLogger("enhanced_technical_analyzer")

class EnhancedTechnicalAnalyzer:
    """Í∏∞Ïà†Ï†Å ÏßÄÌëú Î∂ÑÏÑù AI + Î∞òÏ†Ñ Ïã†Ìò∏ Î∂ÑÏÑù - ÌÜµÌï© Î≤ÑÏ†Ñ"""
    
    def __init__(self):
        # AI Î™®Îç∏ Ï¥àÍ∏∞Ìôî Ï†úÍ±∞ - Ïã§Ï†ú Ìò∏Ï∂ú ÏãúÏóêÎßå Ï¥àÍ∏∞Ìôî
        self.client = None
        self.model_name = None
        
        # üîß ÏÉàÎ°ú Ï∂îÍ∞Ä: ÎèôÏ†Å timeframe ÏÑ§Ï†ï
        self.get_timevalue = TRADING_CONFIG.get('set_timevalue', '1h')  # Í∏∞Î≥∏Í∞íÏùÑ 1hÎ°ú Î≥ÄÍ≤Ω
        self.int_timevalue = TIME_VALUES.get(self.get_timevalue, 60)  # Í∏∞Î≥∏Í∞íÏùÄ 60Î∂Ñ (1ÏãúÍ∞Ñ)
        logger.info(f"ÎèôÏ†Å timeframe ÏÑ§Ï†ï: {self.get_timevalue} ({self.int_timevalue}Î∂Ñ)")
        
        # Î∞òÏ†Ñ Î∂ÑÏÑù ÏÑ§Ï†ï (1ÏãúÍ∞ÑÎ¥â ÏµúÏ†ÅÌôî)
        self.reversal_config = {
            'LINEAR_REG': {
                'LENGTH': 168,  # 1Ï£ºÏùº (24h * 7d = 168h)
                'UPPER_MULTIPLIER': 2.0,
                'LOWER_MULTIPLIER': 2.0,
                'MIN_SLOPE_THRESHOLD': 0.0005,
                'MIN_TREND_DURATION': 24  # 1Ïùº = 24ÏãúÍ∞Ñ
            },
            'DIVERGENCE': {
                'LOOKBACK_PERIOD': 120,  # 5Ïùº (120ÏãúÍ∞Ñ)
                'MIN_PEAK_DISTANCE': 8,  # 8ÏãúÍ∞Ñ Í∞ÑÍ≤©
                'PRICE_THRESHOLD': 0.015,  # 1.5% Ïù¥ÏÉÅ ÏõÄÏßÅÏûÑ
                'INDICATOR_THRESHOLD': 8   # ÏßÄÌëú Î≥ÄÌôîÎüâ Ï¶ùÍ∞Ä
            },
            'PATTERN': {
                'DOUBLE_TOP_BOTTOM_TOLERANCE': 0.02,  # 2%
                'MIN_PATTERN_BARS': 24,  # ÏµúÏÜå 1Ïùº (24ÏãúÍ∞Ñ)
                'MAX_PATTERN_BARS': 168  # ÏµúÎåÄ 1Ï£ºÏùº (168ÏãúÍ∞Ñ)
            },
            'MOMENTUM': {
                'RSI_PERIOD': 14,
                'STOCH_K': 14,
                'STOCH_D': 3,
                'WILLIAMS_R': 14
            },
            'VOLUME': {
                'OBV_SMOOTHING': 12,  # 12ÏãúÍ∞Ñ ÌèâÌôúÌôî
                'VOLUME_SMA': 24,     # 24ÏãúÍ∞Ñ ÌèâÍ∑† Î≥ºÎ•®
                'TREND_PERIOD': 48    # 2ÏùºÍ∞Ñ Î≥ºÎ•® Ìä∏Î†åÎìú
            },
            'SUPPORT_RESISTANCE': {
                'LOOKBACK_PERIOD': 240,  # 10Ïùº (240ÏãúÍ∞Ñ)
                'PIVOT_DISTANCE': 6,     # 6ÏãúÍ∞Ñ Í∞ÑÍ≤©
                'PROXIMITY_THRESHOLD': 0.015,  # 1.5% Ïù¥ÎÇ¥Î•º Í∑ºÏ†ëÏúºÎ°ú ÌåêÎã®
                'RECENT_LEVELS_COUNT': 5  # ÏµúÍ∑º 5Í∞ú Î†àÎ≤® Í≥†Î†§
            }
        }
    
    def get_chart_data(self, symbol='BTCUSDT', timeframe=None, limit=300):
        """Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë (ÎèôÏ†Å timeframe ÏÇ¨Ïö©, ÎØ∏ÏôÑÏÑ± Ï∫îÎì§ Ï†úÏô∏)"""
        try:
            # üîß ÏàòÏ†ï: timeframeÏù¥ NoneÏù¥Î©¥ TRADING_CONFIGÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
            if timeframe is None:
                timeframe = self.get_timevalue
            
            from pymongo import MongoClient
            
            mongoClient = MongoClient("mongodb://mongodb:27017")
            database = mongoClient["bitcoin"]
            
            # üîß ÏàòÏ†ï: ÎèôÏ†Å Ïª¨Î†âÏÖò Ïù¥Î¶Ñ ÏÉùÏÑ±
            chart_collections = {
                '1m': 'chart_1m',
                '3m': 'chart_3m', 
                '5m': 'chart_5m',
                '15m': 'chart_15m',
                '60m': 'chart_60m',  # ÏÉàÎ°ú Ï∂îÍ∞Ä
                '1h': 'chart_60m',   # 1hÎäî 60mÍ≥º ÎèôÏùº
                '30d': 'chart_30d'
            }
            
            if timeframe not in chart_collections:
                raise ValueError(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÏãúÍ∞ÑÎ¥â: {timeframe}")
            
            chart_collection = database[chart_collections[timeframe]]
            
            # Î∂ÑÏÑùÏóê ÌïÑÏöîÌïú ÏôÑÏÑ±Îêú Ï∫îÎì§ ÏàòÎßåÌÅº Í∞ÄÏ†∏Ïò§Í∏∞ ÏúÑÌï¥ 1Í∞úÎ•º Îçî ÏöîÏ≤≠
            data_cursor = chart_collection.find().sort("timestamp", -1).limit(limit + 1)
            data_list = list(data_cursor)
            
            if not data_list:
                raise ValueError("Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§")
            
            df = pd.DataFrame(data_list)
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            
            if '_id' in df.columns:
                df.drop('_id', axis=1, inplace=True)
            
            df.set_index('timestamp', inplace=True)
            df.sort_index(inplace=True)  # ÏãúÍ∞ÑÏàú Ï†ïÎ†¨
            
            # --- ÌïµÏã¨ ÏàòÏ†ï ÏÇ¨Ìï≠ ---
            # Í∞ÄÏû• ÏµúÏã† Îç∞Ïù¥ÌÑ∞Îäî ÎØ∏ÏôÑÏÑ± Ï∫îÎì§Ïùº Í∞ÄÎä•ÏÑ±Ïù¥ ÎÜíÏúºÎØÄÎ°ú Ï†úÍ±∞Ìï©ÎãàÎã§.
            # iloc[:-1]ÏùÄ ÎßàÏßÄÎßâ ÌñâÏùÑ Ï†úÏô∏Ìïú Î™®Îì† ÌñâÏùÑ ÏÑ†ÌÉùÌï©ÎãàÎã§.
            df = df.iloc[:-1]
            
            logger.info(f"ÏôÑÏÑ±Îêú Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë ÏôÑÎ£å: {len(df)}Í∞ú Ï∫îÎì§ ({timeframe})")
            return df
            
        except Exception as e:
            logger.error(f"Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ï§ë Ïò§Î•ò: {e}")
            return None
    
    def find_peaks_and_troughs(self, series: pd.Series, distance: int = None) -> Tuple[List[int], List[int]]:
        """ÌîºÌÅ¨ÏôÄ Í≥® Ï∞æÍ∏∞ (Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Î∂ÑÏÑùÏö©) - 1ÏãúÍ∞ÑÎ¥â ÏµúÏ†ÅÌôî"""
        try:
            # distanceÍ∞Ä ÏßÄÏ†ïÎêòÏßÄ ÏïäÏúºÎ©¥ configÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
            if distance is None:
                distance = self.reversal_config['DIVERGENCE']['MIN_PEAK_DISTANCE']
                
            peaks = []
            troughs = []
            
            for i in range(distance, len(series) - distance):
                # ÌîºÌÅ¨ Ï∞æÍ∏∞
                is_peak = True
                for j in range(i - distance, i + distance + 1):
                    if j != i and series.iloc[j] >= series.iloc[i]:
                        is_peak = False
                        break
                if is_peak:
                    peaks.append(i)
                
                # Í≥® Ï∞æÍ∏∞
                is_trough = True
                for j in range(i - distance, i + distance + 1):
                    if j != i and series.iloc[j] <= series.iloc[i]:
                        is_trough = False
                        break
                if is_trough:
                    troughs.append(i)
            
            return peaks, troughs
            
        except Exception as e:
            logger.error(f"ÌîºÌÅ¨/Í≥® Ï∞æÍ∏∞ Ï§ë Ïò§Î•ò: {e}")
            return [], []
    
    def calculate_linear_regression_channel(self, df: pd.DataFrame) -> pd.DataFrame:
        """ÏàòÏ†ïÎêú ÏÑ†ÌòïÌöåÍ∑Ä Ï±ÑÎÑê Í≥ÑÏÇ∞"""
        try:
            length = self.reversal_config['LINEAR_REG']['LENGTH']
            upper_mult = self.reversal_config['LINEAR_REG']['UPPER_MULTIPLIER']
            lower_mult = self.reversal_config['LINEAR_REG']['LOWER_MULTIPLIER']
            
            # Í≤∞Í≥º Ï†ÄÏû•Ïö© Ïª¨Îüº Ï¥àÍ∏∞Ìôî
            df['lr_slope'] = np.nan
            df['lr_intercept'] = np.nan
            df['lr_middle'] = np.nan
            df['lr_upper'] = np.nan
            df['lr_lower'] = np.nan
            df['lr_std'] = np.nan
            df['lr_trend_strength'] = np.nan
            df['lr_position'] = np.nan
            
            # ÏÑ†ÌòïÌöåÍ∑Ä Í≥ÑÏÇ∞
            for i in range(length - 1, len(df)):
                # ÏµúÍ∑º lengthÍ∞úÏùò Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©
                y_data = df['close'].iloc[i-length+1:i+1].values
                x_data = np.arange(length)
                
                # ÏÑ†ÌòïÌöåÍ∑Ä Í≥ÑÏÇ∞
                slope, intercept, r_value, p_value, std_err = stats.linregress(x_data, y_data)
                
                # ÌòÑÏû¨ ÏãúÏ†êÏùò ÌöåÍ∑ÄÏÑ† Í∞í
                current_regression_value = intercept + slope * (length - 1)
                
                # ÌëúÏ§ÄÌé∏Ï∞® Í≥ÑÏÇ∞ (ÏûîÏ∞® Í∏∞Î∞ò)
                predicted_values = intercept + slope * x_data
                residuals = y_data - predicted_values
                std_dev = np.std(residuals)
                
                # Í≤∞Í≥º Ï†ÄÏû•
                df.loc[df.index[i], 'lr_slope'] = slope
                df.loc[df.index[i], 'lr_intercept'] = intercept
                df.loc[df.index[i], 'lr_middle'] = current_regression_value
                df.loc[df.index[i], 'lr_upper'] = current_regression_value + (std_dev * upper_mult)
                df.loc[df.index[i], 'lr_lower'] = current_regression_value - (std_dev * lower_mult)
                df.loc[df.index[i], 'lr_std'] = std_dev
                df.loc[df.index[i], 'lr_trend_strength'] = abs(r_value)
                
                # ÌòÑÏû¨ Í∞ÄÍ≤©Ïùò Ï±ÑÎÑê ÎÇ¥ ÏúÑÏπò (0~1)
                channel_range = df.loc[df.index[i], 'lr_upper'] - df.loc[df.index[i], 'lr_lower']
                if channel_range > 0:
                    position = (df['close'].iloc[i] - df.loc[df.index[i], 'lr_lower']) / channel_range
                    df.loc[df.index[i], 'lr_position'] = max(0, min(1, position))
                
            logger.info("ÏÑ†ÌòïÌöåÍ∑Ä Ï±ÑÎÑê Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return df
            
        except Exception as e:
            logger.error(f"ÏÑ†ÌòïÌöåÍ∑Ä Ï±ÑÎÑê Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò: {e}")
            return df
    
    def detect_divergence(self, df: pd.DataFrame, price_col: str = 'close', 
                         indicator_col: str = 'rsi') -> pd.DataFrame:
        """Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Í∞êÏßÄ"""
        try:
            lookback = self.reversal_config['DIVERGENCE']['LOOKBACK_PERIOD']
            min_distance = self.reversal_config['DIVERGENCE']['MIN_PEAK_DISTANCE']
            
            # ÏµúÍ∑º Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©
            recent_df = df.tail(lookback).copy()
            
            # ÌîºÌÅ¨ÏôÄ Í≥® Ï∞æÍ∏∞
            price_peaks, price_troughs = self.find_peaks_and_troughs(recent_df[price_col], min_distance)
            indicator_peaks, indicator_troughs = self.find_peaks_and_troughs(recent_df[indicator_col], min_distance)
            
            # Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Ïã†Ìò∏ Ï¥àÍ∏∞Ìôî
            df['bullish_divergence'] = False
            df['bearish_divergence'] = False
            df['divergence_strength'] = 0
            
            # Í∞ïÏÑ∏ Îã§Ïù¥Î≤ÑÏ†ÑÏä§ (Í∞ÄÍ≤©ÏùÄ ÌïòÎùΩ, ÏßÄÌëúÎäî ÏÉÅÏäπ)
            if len(price_troughs) >= 2 and len(indicator_troughs) >= 2:
                recent_price_troughs = [t for t in price_troughs if t >= len(recent_df) - 20]
                recent_indicator_troughs = [t for t in indicator_troughs if t >= len(recent_df) - 20]
                
                if len(recent_price_troughs) >= 2 and len(recent_indicator_troughs) >= 2:
                    p1, p2 = recent_price_troughs[-2], recent_price_troughs[-1]
                    i1, i2 = recent_indicator_troughs[-2], recent_indicator_troughs[-1]
                    
                    price_declining = recent_df[price_col].iloc[p2] < recent_df[price_col].iloc[p1]
                    indicator_rising = recent_df[indicator_col].iloc[i2] > recent_df[indicator_col].iloc[i1]
                    
                    if price_declining and indicator_rising:
                        current_idx = df.index[-1]
                        df.loc[current_idx, 'bullish_divergence'] = True
                        price_change = abs(recent_df[price_col].iloc[p2] - recent_df[price_col].iloc[p1]) / recent_df[price_col].iloc[p1]
                        indicator_change = abs(recent_df[indicator_col].iloc[i2] - recent_df[indicator_col].iloc[i1])
                        df.loc[current_idx, 'divergence_strength'] = min(price_change * 100, indicator_change)
            
            # ÏïΩÏÑ∏ Îã§Ïù¥Î≤ÑÏ†ÑÏä§ (Í∞ÄÍ≤©ÏùÄ ÏÉÅÏäπ, ÏßÄÌëúÎäî ÌïòÎùΩ)
            if len(price_peaks) >= 2 and len(indicator_peaks) >= 2:
                recent_price_peaks = [p for p in price_peaks if p >= len(recent_df) - 20]
                recent_indicator_peaks = [p for p in indicator_peaks if p >= len(recent_df) - 20]
                
                if len(recent_price_peaks) >= 2 and len(recent_indicator_peaks) >= 2:
                    p1, p2 = recent_price_peaks[-2], recent_price_peaks[-1]
                    i1, i2 = recent_indicator_peaks[-2], recent_indicator_peaks[-1]
                    
                    price_rising = recent_df[price_col].iloc[p2] > recent_df[price_col].iloc[p1]
                    indicator_declining = recent_df[indicator_col].iloc[i2] < recent_df[indicator_col].iloc[i1]
                    
                    if price_rising and indicator_declining:
                        current_idx = df.index[-1]
                        df.loc[current_idx, 'bearish_divergence'] = True
                        price_change = abs(recent_df[price_col].iloc[p2] - recent_df[price_col].iloc[p1]) / recent_df[price_col].iloc[p1]
                        indicator_change = abs(recent_df[indicator_col].iloc[i2] - recent_df[indicator_col].iloc[i1])
                        df.loc[current_idx, 'divergence_strength'] = min(price_change * 100, indicator_change)
            
            return df
            
        except Exception as e:
            logger.error(f"Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Í∞êÏßÄ Ï§ë Ïò§Î•ò: {e}")
            return df
    
    def detect_double_patterns(self, df: pd.DataFrame) -> pd.DataFrame:
        """Ïù¥Ï§ë Ï≤úÏ†ï/Î∞îÎã• Ìå®ÌÑ¥ Í∞êÏßÄ"""
        try:
            tolerance = self.reversal_config['PATTERN']['DOUBLE_TOP_BOTTOM_TOLERANCE']
            min_bars = self.reversal_config['PATTERN']['MIN_PATTERN_BARS']
            max_bars = self.reversal_config['PATTERN']['MAX_PATTERN_BARS']
            
            df['double_top'] = False
            df['double_bottom'] = False
            df['pattern_strength'] = 0
            
            if len(df) < min_bars * 2:
                return df
            
            # ÏµúÍ∑º Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ìå®ÌÑ¥ Ï∞æÍ∏∞
            recent_data = df.tail(max_bars)
            highs = recent_data['high']
            lows = recent_data['low']
            
            # Ïù¥Ï§ë Ï≤úÏ†ï Ìå®ÌÑ¥
            high_peaks, _ = self.find_peaks_and_troughs(highs, 3)
            if len(high_peaks) >= 2:
                peak1_val = highs.iloc[high_peaks[-2]]
                peak2_val = highs.iloc[high_peaks[-1]]
                
                if abs(peak1_val - peak2_val) / peak1_val <= tolerance:
                    between_min = highs.iloc[high_peaks[-2]:high_peaks[-1]].min()
                    if (peak1_val - between_min) / peak1_val > tolerance:
                        current_idx = df.index[-1]
                        df.loc[current_idx, 'double_top'] = True
                        df.loc[current_idx, 'pattern_strength'] = 1 - abs(peak1_val - peak2_val) / peak1_val
            
            # Ïù¥Ï§ë Î∞îÎã• Ìå®ÌÑ¥
            _, low_troughs = self.find_peaks_and_troughs(lows, 3)
            if len(low_troughs) >= 2:
                trough1_val = lows.iloc[low_troughs[-2]]
                trough2_val = lows.iloc[low_troughs[-1]]
                
                if abs(trough1_val - trough2_val) / trough1_val <= tolerance:
                    between_max = lows.iloc[low_troughs[-2]:low_troughs[-1]].max()
                    if (between_max - trough1_val) / trough1_val > tolerance:
                        current_idx = df.index[-1]
                        df.loc[current_idx, 'double_bottom'] = True
                        df.loc[current_idx, 'pattern_strength'] = 1 - abs(trough1_val - trough2_val) / trough1_val
            
            return df
            
        except Exception as e:
            logger.error(f"Ïù¥Ï§ë Ìå®ÌÑ¥ Í∞êÏßÄ Ï§ë Ïò§Î•ò: {e}")
            return df
    
    def calculate_reversal_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Î∞òÏ†Ñ Ïã†Ìò∏ Ï¢ÖÌï© Í≥ÑÏÇ∞"""
        try:
            # 1. ÏÑ†ÌòïÌöåÍ∑Ä Ï±ÑÎÑê
            df = self.calculate_linear_regression_channel(df)
            
            # 2. Í∏∞Î≥∏ Î™®Î©òÌÖÄ ÏßÄÌëúÎì§ (Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Î∂ÑÏÑùÏö©)
            rsi_period = self.reversal_config['MOMENTUM']['RSI_PERIOD']
            df['reversal_rsi'] = ta.momentum.rsi(df['close'], window=rsi_period)
            df['reversal_stoch'] = ta.momentum.stoch(df['high'], df['low'], df['close'], window=14)
            df['reversal_williams'] = ta.momentum.williams_r(df['high'], df['low'], df['close'], lbp=14)
            
            # 3. Î≥ºÎ•® ÏßÄÌëúÎì§
            df['obv'] = ta.volume.on_balance_volume(df['close'], df['volume'])
            df['obv_smooth'] = df['obv'].rolling(window=self.reversal_config['VOLUME']['OBV_SMOOTHING']).mean()
            
            # 4. Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Î∂ÑÏÑù (Ïó¨Îü¨ ÏßÄÌëú)
            momentum_indicators = ['reversal_rsi', 'reversal_stoch', 'reversal_williams']
            df['momentum_bullish_signals'] = 0
            df['momentum_bearish_signals'] = 0
            
            for indicator in momentum_indicators:
                if indicator in df.columns and not df[indicator].isna().all():
                    temp_df = self.detect_divergence(df.copy(), 'close', indicator)
                    
                    if len(temp_df) > 0 and temp_df['bullish_divergence'].iloc[-1]:
                        df.loc[df.index[-1], 'momentum_bullish_signals'] += 1
                    
                    if len(temp_df) > 0 and temp_df['bearish_divergence'].iloc[-1]:
                        df.loc[df.index[-1], 'momentum_bearish_signals'] += 1
            
            # 5. Î≥ºÎ•® Îã§Ïù¥Î≤ÑÏ†ÑÏä§
            df = self.detect_divergence(df, 'close', 'obv_smooth')
            df['volume_divergence_bullish'] = df['bullish_divergence']
            df['volume_divergence_bearish'] = df['bearish_divergence']
            
            # 6. Ìå®ÌÑ¥ Î∂ÑÏÑù
            df = self.detect_double_patterns(df)
            
            # 7. ÏßÄÏßÄ/Ï†ÄÌï≠ Î∂ÑÏÑù
            df = self.calculate_support_resistance_levels(df)
            
            logger.info("Î∞òÏ†Ñ ÏßÄÌëú Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return df
            
        except Exception as e:
            logger.error(f"Î∞òÏ†Ñ ÏßÄÌëú Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò: {e}")
            return df
    
    def calculate_support_resistance_levels(self, df: pd.DataFrame) -> pd.DataFrame:
        """ÏßÄÏßÄ/Ï†ÄÌï≠ Î†àÎ≤® Í≥ÑÏÇ∞"""
        try:
            lookback = min(self.reversal_config['SUPPORT_RESISTANCE']['LOOKBACK_PERIOD'], len(df))
            pivot_distance = self.reversal_config['SUPPORT_RESISTANCE']['PIVOT_DISTANCE']
            proximity_threshold = self.reversal_config['SUPPORT_RESISTANCE']['PROXIMITY_THRESHOLD']
            
            recent_data = df.tail(lookback)
            high_peaks, low_troughs = self.find_peaks_and_troughs(recent_data['close'], pivot_distance)
            
            if high_peaks and low_troughs:
                # Ï†ÄÌï≠ÏÑ†Í≥º ÏßÄÏßÄÏÑ† Í≥ÑÏÇ∞
                resistance_levels = [recent_data['high'].iloc[i] for i in high_peaks[-5:]]
                support_levels = [recent_data['low'].iloc[i] for i in low_troughs[-5:]]
                
                current_resistance = np.mean(resistance_levels) if resistance_levels else recent_data['high'].max()
                current_support = np.mean(support_levels) if support_levels else recent_data['low'].min()
                
                current_price = df['close'].iloc[-1]
                resistance_distance = (current_resistance - current_price) / current_price
                support_distance = (current_price - current_support) / current_price
                
                df['resistance_level'] = current_resistance
                df['support_level'] = current_support
                df['resistance_distance'] = resistance_distance
                df['support_distance'] = support_distance
                
                # Î∞òÏ†Ñ Ïã†Ìò∏
                df['near_resistance'] = resistance_distance < proximity_threshold
                df['near_support'] = support_distance < proximity_threshold
                df['resistance_reversal'] = df['near_resistance'] & (df['close'] < df['close'].shift(1))
                df['support_reversal'] = df['near_support'] & (df['close'] > df['close'].shift(1))
            
            return df
            
        except Exception as e:
            logger.error(f"ÏßÄÏßÄ/Ï†ÄÌï≠ Î†àÎ≤® Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò: {e}")
            return df
    
    def calculate_technical_indicators(self, df):
        """Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ - ÏÉàÎ°úÏö¥ Ï†ïÎ¶¨Îêú ÏΩîÎìú ÏÇ¨Ïö© + Î∞òÏ†Ñ Î∂ÑÏÑù Ï∂îÍ∞Ä"""
        try:
            # Í∏∞Ï°¥ Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
            processed_df, config_info = calculate_technical_indicators(df)
            
            # Î∞òÏ†Ñ Î∂ÑÏÑù Ï∂îÍ∞Ä
            processed_df = self.calculate_reversal_indicators(processed_df)
            
            logger.info("Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return processed_df, config_info
            
        except Exception as e:
            logger.error(f"ÏßÄÌëú Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò: {e}")
            # Î∞±ÏóÖ: Í∏∞Î≥∏ ÏßÄÌëúÎßå Í≥ÑÏÇ∞
            return self.calculate_basic_indicators(df)
    
    def calculate_basic_indicators(self, df):
        """Í∏∞Î≥∏ Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ (Î∞±ÏóÖÏö©)"""
        try:
            import ta
            
            # Í∏∞Î≥∏ ÏßÄÌëúÎì§
            df['rsi'] = ta.momentum.rsi(df['close'], window=14)
            df['ema_20'] = df['close'].ewm(span=20).mean()
            df['ema_50'] = df['close'].ewm(span=50).mean()
            
            # MACD
            ema_12 = df['close'].ewm(span=12).mean()
            ema_26 = df['close'].ewm(span=26).mean()
            df['macd'] = ema_12 - ema_26
            df['macd_signal'] = df['macd'].ewm(span=9).mean()
            df['macd_histogram'] = df['macd'] - df['macd_signal']
            
            # Bollinger Bands
            df['bb_middle'] = df['close'].rolling(window=20).mean()
            bb_std = df['close'].rolling(window=20).std()
            df['bb_upper'] = df['bb_middle'] + (bb_std * 2)
            df['bb_lower'] = df['bb_middle'] - (bb_std * 2)
            df['bb_position'] = (df['close'] - df['bb_lower']) / (df['bb_upper'] - df['bb_lower']) * 100
            
            logger.info("Í∏∞Î≥∏ Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞ ÏôÑÎ£å")
            return df, {}
            
        except Exception as e:
            logger.error(f"Í∏∞Î≥∏ ÏßÄÌëú Í≥ÑÏÇ∞ Ï§ë Ïò§Î•ò: {e}")
            return df, {}
    
    def extract_key_indicators(self, df, config_info):
        """AI Î∂ÑÏÑùÏö© ÌïµÏã¨ ÏßÄÌëú Ï∂îÏ∂ú - Î∞òÏ†Ñ Î∂ÑÏÑù Ìè¨Ìï®"""
        try:
            # Í∏∞Ï°¥ ÏßÄÌëú Ï∂îÏ∂ú
            latest_indicators = get_latest_indicators(df)
            
            if not latest_indicators:
                raise ValueError("ÏßÄÌëú Ï∂îÏ∂ú Ïã§Ìå®")
            
            # ÎèôÏ†Å 24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•† Í≥ÑÏÇ∞
            current_price = latest_indicators['basic']['current_price']
            price_change_24h = 0
            
            candles_per_24h = int(24 * 60 / self.int_timevalue)
            
            if len(df) >= candles_per_24h:
                price_24h_ago = float(df.iloc[-candles_per_24h]['close'])
                price_change_24h = ((current_price - price_24h_ago) / price_24h_ago * 100)
                logger.info(f"24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•† Í≥ÑÏÇ∞: {candles_per_24h}Í∞ú Ï∫îÎì§ ÏÇ¨Ïö© ({self.get_timevalue})")
            
            # Î∞òÏ†Ñ Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
            latest = df.iloc[-1]
            
            # Í∞ïÏÑ∏ Î∞òÏ†Ñ Ïã†Ìò∏Îì§
            bullish_signals = []
            if latest.get('bullish_divergence', False):
                bullish_signals.append('price_momentum_divergence')
            if latest.get('double_bottom', False):
                bullish_signals.append('double_bottom_pattern')
            if latest.get('momentum_bullish_signals', 0) > 0:
                bullish_signals.append(f'momentum_divergence_{latest.get("momentum_bullish_signals", 0)}_indicators')
            if latest.get('volume_divergence_bullish', False):
                bullish_signals.append('volume_divergence')
            if latest.get('support_reversal', False):
                bullish_signals.append('support_level_bounce')
            if latest.get('lr_position', 0.5) < 0.2:
                bullish_signals.append('linear_regression_oversold')
            
            # ÏïΩÏÑ∏ Î∞òÏ†Ñ Ïã†Ìò∏Îì§
            bearish_signals = []
            if latest.get('bearish_divergence', False):
                bearish_signals.append('price_momentum_divergence')
            if latest.get('double_top', False):
                bearish_signals.append('double_top_pattern')
            if latest.get('momentum_bearish_signals', 0) > 0:
                bearish_signals.append(f'momentum_divergence_{latest.get("momentum_bearish_signals", 0)}_indicators')
            if latest.get('volume_divergence_bearish', False):
                bearish_signals.append('volume_divergence')
            if latest.get('resistance_reversal', False):
                bearish_signals.append('resistance_level_rejection')
            if latest.get('lr_position', 0.5) > 0.8:
                bearish_signals.append('linear_regression_overbought')
            
            # AIÍ∞Ä Ïù¥Ìï¥ÌïòÍ∏∞ Ïâ¨Ïö¥ ÌòïÌÉúÎ°ú Ïû¨Íµ¨ÏÑ± (Í∏∞Ï°¥ + Î∞òÏ†Ñ Î∂ÑÏÑù)
            analysis_data = {
                'current_price': current_price,
                'price_change_24h': round(price_change_24h, 2),
                'volume': latest_indicators['basic']['volume'],
                'timestamp': latest_indicators['basic']['timestamp'],
                'timeframe_info': {
                    'timeframe': self.get_timevalue,
                    'minutes_per_candle': self.int_timevalue,
                    'candles_per_24h': candles_per_24h
                },
                
                # Í∏∞Ï°¥ Ï∂îÏÑ∏ Î∂ÑÏÑù
                'trend_indicators': {
                    'ema_fast': latest_indicators['trend']['ema_fast'],
                    'ema_slow': latest_indicators['trend']['ema_slow'],
                    'ema_signal': 'bullish' if latest_indicators['trend']['ema_fast'] > latest_indicators['trend']['ema_slow'] else 'bearish',
                    'macd': latest_indicators['trend']['macd'],
                    'macd_signal': latest_indicators['trend']['macd_signal'],
                    'macd_histogram': latest_indicators['trend']['macd_histogram'],
                    'macd_status': 'bullish' if latest_indicators['trend']['macd'] > latest_indicators['trend']['macd_signal'] else 'bearish',
                    'adx': latest_indicators['trend']['adx'],
                    'adx_strength': 'strong' if latest_indicators['trend']['adx'] > 25 else 'weak',
                    'di_plus': latest_indicators['trend']['di_plus'],
                    'di_minus': latest_indicators['trend']['di_minus'],
                    'di_signal': 'bullish' if latest_indicators['trend']['di_plus'] > latest_indicators['trend']['di_minus'] else 'bearish'
                },
                
                # Í∏∞Ï°¥ Î™®Î©òÌÖÄ Î∂ÑÏÑù
                'momentum_indicators': {
                    'rsi': latest_indicators['momentum']['rsi'],
                    'rsi_state': latest_indicators['momentum']['momentum_state'],
                    'stoch_k': latest_indicators['momentum']['stoch_k'],
                    'stoch_d': latest_indicators['momentum']['stoch_d'],
                    'stoch_signal': 'bullish' if latest_indicators['momentum']['stoch_k'] > latest_indicators['momentum']['stoch_d'] else 'bearish',
                    'williams_r': latest_indicators['momentum']['williams_r'],
                    'williams_state': 'oversold' if latest_indicators['momentum']['williams_r'] > -20 else 'overbought' if latest_indicators['momentum']['williams_r'] < -80 else 'neutral'
                },
                
                # Í∏∞Ï°¥ Î≥ÄÎèôÏÑ± Î∂ÑÏÑù
                'volatility_indicators': {
                    'bb_position': latest_indicators['volatility']['bb_position'],
                    'bb_upper': latest_indicators['volatility']['bb_upper'],
                    'bb_lower': latest_indicators['volatility']['bb_lower'],
                    'bb_middle': latest_indicators['volatility']['bb_middle'],
                    'bb_signal': 'overbought' if latest_indicators['volatility']['bb_position'] > 80 else 'oversold' if latest_indicators['volatility']['bb_position'] < 20 else 'neutral',
                    'atr': latest_indicators['volatility']['atr'],
                    'atr_percent': latest_indicators['volatility']['atr_percent'],
                    'volatility_level': latest_indicators['volatility']['volatility_level']
                },
                
                # Í∏∞Ï°¥ Î≥ºÎ•® Î∂ÑÏÑù
                'volume_indicators': {
                    'volume_ratio': latest_indicators['volume']['volume_ratio'],
                    'volume_state': latest_indicators['volume']['volume_state'],
                    'obv_trend': 'bullish' if latest_indicators['volume']['obv_trend'] > 0 else 'bearish',
                    'mfi': latest_indicators['volume']['mfi'],
                    'mfi_state': 'overbought' if latest_indicators['volume']['mfi'] > 80 else 'oversold' if latest_indicators['volume']['mfi'] < 20 else 'neutral'
                },
                
                # Í∏∞Ï°¥ ÏßÄÏßÄ/Ï†ÄÌï≠ Î∂ÑÏÑù
                'support_resistance': {
                    'support_level': latest_indicators['support_resistance']['support'],
                    'resistance_level': latest_indicators['support_resistance']['resistance'],
                    'price_position': latest_indicators['support_resistance']['price_position'],
                    'breakout_potential': latest_indicators['support_resistance']['breakout_potential'],
                    'support_distance': round(((current_price - latest_indicators['support_resistance']['support']) / current_price) * 100, 2),
                    'resistance_distance': round(((latest_indicators['support_resistance']['resistance'] - current_price) / current_price) * 100, 2)
                },
                
                # üÜï ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú Î∞òÏ†Ñ Î∂ÑÏÑù
                'reversal_analysis': {
                    'bullish_reversal_signals': bullish_signals,
                    'bearish_reversal_signals': bearish_signals,
                    'bullish_signal_count': len(bullish_signals),
                    'bearish_signal_count': len(bearish_signals),
                    'net_signal_bias': len(bullish_signals) - len(bearish_signals),
                    
                    'pattern_analysis': {
                        'double_top_detected': bool(latest.get('double_top', False)),
                        'double_bottom_detected': bool(latest.get('double_bottom', False)),
                        'pattern_strength': float(latest.get('pattern_strength', 0))
                    },
                    
                    'divergence_analysis': {
                        'price_momentum_divergence': bool(latest.get('bullish_divergence', False) or latest.get('bearish_divergence', False)),
                        'volume_divergence': bool(latest.get('volume_divergence_bullish', False) or latest.get('volume_divergence_bearish', False)),
                        'divergence_strength': float(latest.get('divergence_strength', 0)),
                        'momentum_signals': int(latest.get('momentum_bullish_signals', 0) + latest.get('momentum_bearish_signals', 0))
                    },
                    
                    'linear_regression_analysis': {
                        'trend_direction': 'bullish' if latest.get('lr_slope', 0) > 0 else 'bearish',
                        'trend_strength': float(latest.get('lr_trend_strength', 0)),
                        'channel_position': float(latest.get('lr_position', 0.5)),
                        'channel_upper': float(latest.get('lr_upper', 0)),
                        'channel_lower': float(latest.get('lr_lower', 0)),
                        'channel_middle': float(latest.get('lr_middle', 0)),
                        'breakout_potential': 'high' if latest.get('lr_position', 0.5) > 0.9 or latest.get('lr_position', 0.5) < 0.1 else 'low'
                    },
                    
                    'support_resistance_reversal': {
                        'near_support': bool(latest.get('near_support', False)),
                        'near_resistance': bool(latest.get('near_resistance', False)),
                        'support_reversal': bool(latest.get('support_reversal', False)),
                        'resistance_reversal': bool(latest.get('resistance_reversal', False)),
                        'enhanced_support_level': float(latest.get('support_level', 0)),
                        'enhanced_resistance_level': float(latest.get('resistance_level', 0))
                    }
                }
            }
            
            logger.info("AIÏö© ÌïµÏã¨ ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù Ï∂îÏ∂ú ÏôÑÎ£å")
            return analysis_data
            
        except Exception as e:
            logger.error(f"ÌïµÏã¨ ÏßÄÌëú Ï∂îÏ∂ú Ï§ë Ïò§Î•ò: {e}")
            return {
                'current_price': 0,
                'price_change_24h': 0,
                'volume': 0,
                'error': str(e)
            }
    
    def get_model(self):
        """AI Î™®Îç∏ÏùÑ ÌïÑÏöîÌï† ÎïåÎßå Ï¥àÍ∏∞Ìôî"""
        if not API_KEY:
            return None, None
            
        try:
            client = genai.Client(api_key=API_KEY)
            
            for model_name in MODEL_PRIORITY:
                try:
                    return client, model_name
                except Exception as e:
                    logger.warning(f"Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Î™®Îç∏ {model_name} Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
                    continue
            
            return None, None
            
        except Exception as e:
            logger.error(f"Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Î™®Îç∏ Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•ò: {e}")
            return None, None

    async def analyze_with_ai(self, indicators_data: Dict) -> Dict:
        """AI Î™®Îç∏ÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù"""
        # ÌïÑÏöîÌï† ÎïåÎßå Î™®Îç∏ Ï¥àÍ∏∞Ìôî
        if self.client is None:
            self.client, self.model_name = self.get_model()
        
        try:
            # Î∞òÏ†Ñ Î∂ÑÏÑùÏù¥ Ìè¨Ìï®Îêú Ìñ•ÏÉÅÎêú ÌîÑÎ°¨ÌîÑÌä∏ Íµ¨ÏÑ±
            enhanced_prompt = f"""
ÎãπÏã†ÏùÄ Ï†ÑÎ¨∏ ÎπÑÌä∏ÏΩîÏù∏ Í∏∞Ïà†Ï†Å Î∂ÑÏÑùÍ∞ÄÏûÖÎãàÎã§. Îã§Ïùå Îç∞Ïù¥ÌÑ∞Î•º Î∞îÌÉïÏúºÎ°ú Ï¢ÖÌï©Ï†ÅÏù∏ Î∂ÑÏÑùÏùÑ ÏàòÌñâÌïòÏÑ∏Ïöî.

Í∏∞Î≥∏ Ï†ïÎ≥¥:
- ÌòÑÏû¨ Í∞ÄÍ≤©: ${indicators_data['current_price']:,.2f}
- 24ÏãúÍ∞Ñ Î≥ÄÎèô: {indicators_data['price_change_24h']:.2f}%
- ÏãúÍ∞ÑÎ¥â: {indicators_data['timeframe_info']['timeframe']}
- Î≥ºÎ•®: {indicators_data['volume']:,.0f}

Í∏∞Ïà†Ï†Å ÏßÄÌëú Îç∞Ïù¥ÌÑ∞:
{json.dumps(indicators_data, ensure_ascii=False, indent=2)}

ÌäπÌûà Îã§Ïùå Î∞òÏ†Ñ Ïã†Ìò∏Îì§Ïóê Ï£ºÎ™©ÌïòÏÑ∏Ïöî:
- Í∞ïÏÑ∏ Î∞òÏ†Ñ Ïã†Ìò∏: {indicators_data.get('reversal_analysis', {}).get('bullish_reversal_signals', [])}
- ÏïΩÏÑ∏ Î∞òÏ†Ñ Ïã†Ìò∏: {indicators_data.get('reversal_analysis', {}).get('bearish_reversal_signals', [])}
- Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Î∂ÑÏÑù: {indicators_data.get('reversal_analysis', {}).get('divergence_analysis', {})}
- Ìå®ÌÑ¥ Î∂ÑÏÑù: {indicators_data.get('reversal_analysis', {}).get('pattern_analysis', {})}
- ÏÑ†ÌòïÌöåÍ∑Ä Ï±ÑÎÑê: {indicators_data.get('reversal_analysis', {}).get('linear_regression_analysis', {})}

Îã§Ïùå JSON ÌòïÏãùÏúºÎ°ú ÏùëÎãµÌï¥Ï£ºÏÑ∏Ïöî:
{{
  "overall_signal": "Strong Buy/Buy/Hold/Sell/Strong Sell",
  "trend_analysis": {{
    "trend_direction": "ÏÉÅÏäπ/ÌïòÎùΩ/Ìö°Î≥¥",
    "trend_strength": 0-100,
    "reversal_probability": 0-100,
    "key_support_level": Ïà´Ïûê,
    "key_resistance_level": Ïà´Ïûê
  }},
  "momentum_analysis": {{
    "momentum_direction": "ÏÉÅÏäπ/ÌïòÎùΩ/Ï§ëÎ¶Ω",
    "momentum_strength": 0-100,
    "divergence_signals": "Í∞ïÏÑ∏/ÏïΩÏÑ∏/ÏóÜÏùå",
    "oversold_overbought": "Í≥ºÎß§Ïàò/Í≥ºÎß§ÎèÑ/Ï§ëÎ¶Ω"
  }},
  "reversal_analysis": {{
    "reversal_probability": 0-100,
    "reversal_direction": "ÏÉÅÏäπÎ∞òÏ†Ñ/ÌïòÎùΩÎ∞òÏ†Ñ/ÏóÜÏùå",
    "key_reversal_signals": ["Ïã†Ìò∏1", "Ïã†Ìò∏2"],
    "pattern_confirmation": "ÌôïÏù∏Îê®/ÎØ∏ÌôïÏù∏",
    "divergence_strength": 0-100
  }},
  "volatility_analysis": {{
    "volatility_level": "ÎÜíÏùå/Ï§ëÍ∞Ñ/ÎÇÆÏùå",
    "breakout_probability": 0-100,
    "expected_direction": "ÏÉÅÏäπ/ÌïòÎùΩ/Î∂àÌôïÏã§"
  }},
  "volume_analysis": {{
    "volume_trend": "Ï¶ùÍ∞Ä/Í∞êÏÜå/Î≥¥ÌÜµ",
    "volume_confirmation": true/false,
    "institutional_flow": "Îß§Ïàò/Îß§ÎèÑ/Ï§ëÎ¶Ω"
  }},
  "entry_exit_points": {{
    "best_entry_long": Ïà´Ïûê,
    "best_entry_short": Ïà´Ïûê,
    "stop_loss_long": Ïà´Ïûê,
    "stop_loss_short": Ïà´Ïûê,
    "take_profit_long": Ïà´Ïûê,
    "take_profit_short": Ïà´Ïûê
  }},
  "timeframe_analysis": {{
    "short_term": "1ÏãúÍ∞Ñ-4ÏãúÍ∞Ñ Ï†ÑÎßù",
    "medium_term": "1Ïùº-1Ï£ºÏùº Ï†ÑÎßù", 
    "long_term": "1Ï£ºÏùº-1Í∞úÏõî Ï†ÑÎßù"
  }},
  "confidence": 0-100,
  "analysis_summary": "ÌïµÏã¨ Î∂ÑÏÑù ÏöîÏïΩ"
}}
"""
            
            # AI Î™®Îç∏Ïóê ÏßàÏùò
            response = self.client.models.generate_content(
                model=self.model_name,
                contents=enhanced_prompt
            )
            
            # JSON ÌååÏã±
            result_text = response.text
            json_match = re.search(r'\{[\s\S]*\}', result_text)
            if json_match:
                result_json = json.loads(json_match.group(0))
                
                # Î∂ÑÏÑù Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
                result_json['analysis_metadata'] = {
                    'analysis_type': 'ai_based_enhanced',
                    'data_timestamp': datetime.now(timezone.utc).isoformat(),
                    'model_used': self.model_name,
                    'timeframe_used': self.get_timevalue,
                    'reversal_signals_analyzed': True,
                    'raw_data': indicators_data
                }
                
                return result_json
            else:
                logger.error("AI ÏùëÎãµÏóêÏÑú JSONÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
                return self.rule_based_analysis_enhanced(indicators_data)
                
        except Exception as e:
            logger.error(f"AI Í∏∞Ïà†Ï†Å Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {e}")
            return self.rule_based_analysis_enhanced(indicators_data)
    
    def rule_based_analysis_enhanced(self, indicators_data: Dict) -> Dict:
        """Í∑úÏπô Í∏∞Î∞ò Í∏∞Ïà†Ï†Å Î∂ÑÏÑù + Î∞òÏ†Ñ Î∂ÑÏÑù (AI Î™®Îç∏ ÏóÜÏùÑ Îïå Î∞±ÏóÖ)"""
        try:
            trend_indicators = indicators_data.get('trend_indicators', {})
            momentum_indicators = indicators_data.get('momentum_indicators', {})
            volatility_indicators = indicators_data.get('volatility_indicators', {})
            volume_indicators = indicators_data.get('volume_indicators', {})
            support_resistance = indicators_data.get('support_resistance', {})
            reversal_analysis = indicators_data.get('reversal_analysis', {})
            
            # Ïã†Ìò∏ Ï†êÏàò Í≥ÑÏÇ∞ (Í∏∞Ï°¥ + Î∞òÏ†Ñ Ïã†Ìò∏ Ï∂îÍ∞Ä)
            signal_score = 0
            total_signals = 0
            
            # Í∏∞Ï°¥ Ï∂îÏÑ∏ Ïã†Ìò∏Îì§
            if trend_indicators.get('ema_signal') == 'bullish':
                signal_score += 1
            elif trend_indicators.get('ema_signal') == 'bearish':
                signal_score -= 1
            total_signals += 1
            
            if trend_indicators.get('macd_status') == 'bullish':
                signal_score += 1
            elif trend_indicators.get('macd_status') == 'bearish':
                signal_score -= 1
            total_signals += 1
            
            # Í∏∞Ï°¥ Î™®Î©òÌÖÄ Ïã†Ìò∏Îì§
            rsi = momentum_indicators.get('rsi', 50)
            if rsi < 30:
                signal_score += 1  # Í≥ºÎß§ÎèÑÏóêÏÑú Îß§Ïàò
            elif rsi > 70:
                signal_score -= 1  # Í≥ºÎß§ÏàòÏóêÏÑú Îß§ÎèÑ
            total_signals += 1
            
            # üÜï Î∞òÏ†Ñ Ïã†Ìò∏Îì§ Ï∂îÍ∞Ä
            bullish_reversal_count = reversal_analysis.get('bullish_signal_count', 0)
            bearish_reversal_count = reversal_analysis.get('bearish_signal_count', 0)
            
            # Î∞òÏ†Ñ Ïã†Ìò∏ Í∞ÄÏ§ëÏπò (Îçî ÎÜíÍ≤å)
            signal_score += bullish_reversal_count * 2  # Í∞ïÏÑ∏ Î∞òÏ†Ñ Ïã†Ìò∏
            signal_score -= bearish_reversal_count * 2  # ÏïΩÏÑ∏ Î∞òÏ†Ñ Ïã†Ìò∏
            total_signals += max(bullish_reversal_count, bearish_reversal_count) * 2
            
            # Îã§Ïù¥Î≤ÑÏ†ÑÏä§ Ïã†Ìò∏
            divergence_signals = reversal_analysis.get('divergence_analysis', {}).get('momentum_signals', 0)
            if divergence_signals > 0:
                signal_score += divergence_signals
                total_signals += divergence_signals
            
            # Ìå®ÌÑ¥ Ïã†Ìò∏
            if reversal_analysis.get('pattern_analysis', {}).get('double_bottom_detected', False):
                signal_score += 2
                total_signals += 2
            elif reversal_analysis.get('pattern_analysis', {}).get('double_top_detected', False):
                signal_score -= 2
                total_signals += 2
            
            # ÏÑ†ÌòïÌöåÍ∑Ä Ï±ÑÎÑê Ïã†Ìò∏
            lr_position = reversal_analysis.get('linear_regression_analysis', {}).get('channel_position', 0.5)
            if lr_position < 0.2:  # Ï±ÑÎÑê ÌïòÎã® = Í∞ïÏÑ∏ Ïã†Ìò∏
                signal_score += 1
            elif lr_position > 0.8:  # Ï±ÑÎÑê ÏÉÅÎã® = ÏïΩÏÑ∏ Ïã†Ìò∏
                signal_score -= 1
            total_signals += 1
            
            # Ï†ÑÏ≤¥ Ïã†Ìò∏ Í∞ïÎèÑ
            signal_strength = abs(signal_score) / total_signals * 100 if total_signals > 0 else 0
            
            # Î∞òÏ†Ñ ÌôïÎ•† Í≥ÑÏÇ∞
            reversal_probability = min(100, (bullish_reversal_count + bearish_reversal_count) * 25)
            reversal_direction = "ÏÉÅÏäπÎ∞òÏ†Ñ" if bullish_reversal_count > bearish_reversal_count else "ÌïòÎùΩÎ∞òÏ†Ñ" if bearish_reversal_count > bullish_reversal_count else "ÏóÜÏùå"
            
            # ÏµúÏ¢Ö Ïã†Ìò∏ Í≤∞Ï†ï (Î∞òÏ†Ñ Ïã†Ìò∏ Í≥†Î†§)
            if signal_score >= 4:
                overall_signal = "Strong Buy"
            elif signal_score >= 2:
                overall_signal = "Buy"
            elif signal_score <= -4:
                overall_signal = "Strong Sell"
            elif signal_score <= -2:
                overall_signal = "Sell"
            else:
                overall_signal = "Hold"
            
            # Í≤∞Í≥º Íµ¨ÏÑ±
            result = {
                "overall_signal": overall_signal,
                "trend_analysis": {
                    "trend_direction": trend_indicators.get('ema_signal', 'neutral').replace('bullish', 'ÏÉÅÏäπ').replace('bearish', 'ÌïòÎùΩ').replace('neutral', 'Ìö°Î≥¥'),
                    "trend_strength": int(signal_strength),
                    "reversal_probability": int(reversal_probability),
                    "key_support_level": support_resistance.get('support_level', 0),
                    "key_resistance_level": support_resistance.get('resistance_level', 0)
                },
                "momentum_analysis": {
                    "momentum_direction": momentum_indicators.get('rsi_state', 'neutral').replace('bullish', 'ÏÉÅÏäπ').replace('bearish', 'ÌïòÎùΩ').replace('neutral', 'Ï§ëÎ¶Ω'),
                    "momentum_strength": int(signal_strength),
                    "divergence_signals": "Í∞ïÏÑ∏" if bullish_reversal_count > bearish_reversal_count else "ÏïΩÏÑ∏" if bearish_reversal_count > bullish_reversal_count else "ÏóÜÏùå",
                    "oversold_overbought": momentum_indicators.get('rsi_state', 'neutral').replace('oversold', 'Í≥ºÎß§ÎèÑ').replace('overbought', 'Í≥ºÎß§Ïàò').replace('neutral', 'Ï§ëÎ¶Ω')
                },
                "reversal_analysis": {
                    "reversal_probability": int(reversal_probability),
                    "reversal_direction": reversal_direction,
                    "key_reversal_signals": reversal_analysis.get('bullish_reversal_signals', []) + reversal_analysis.get('bearish_reversal_signals', []),
                    "pattern_confirmation": "ÌôïÏù∏Îê®" if reversal_analysis.get('pattern_analysis', {}).get('pattern_strength', 0) > 0.5 else "ÎØ∏ÌôïÏù∏",
                    "divergence_strength": int(reversal_analysis.get('divergence_analysis', {}).get('divergence_strength', 0))
                },
                "volatility_analysis": {
                    "volatility_level": volatility_indicators.get('volatility_level', 'medium').replace('high', 'ÎÜíÏùå').replace('medium', 'Ï§ëÍ∞Ñ').replace('low', 'ÎÇÆÏùå'),
                    "breakout_probability": int(signal_strength),
                    "expected_direction": "ÏÉÅÏäπ" if signal_score > 0 else "ÌïòÎùΩ" if signal_score < 0 else "Î∂àÌôïÏã§"
                },
                "volume_analysis": {
                    "volume_trend": volume_indicators.get('volume_state', 'normal').replace('high', 'Ï¶ùÍ∞Ä').replace('normal', 'Î≥¥ÌÜµ').replace('low', 'Í∞êÏÜå'),
                    "volume_confirmation": volume_indicators.get('volume_ratio', 1) > 1.2,
                    "institutional_flow": volume_indicators.get('obv_trend', 'neutral').replace('bullish', 'Îß§Ïàò').replace('bearish', 'Îß§ÎèÑ').replace('neutral', 'Ï§ëÎ¶Ω')
                },
                "entry_exit_points": {
                    "best_entry_long": reversal_analysis.get('support_resistance_reversal', {}).get('enhanced_support_level', support_resistance.get('support_level', 0)),
                    "best_entry_short": reversal_analysis.get('support_resistance_reversal', {}).get('enhanced_resistance_level', support_resistance.get('resistance_level', 0)),
                    "stop_loss_long": reversal_analysis.get('support_resistance_reversal', {}).get('enhanced_support_level', support_resistance.get('support_level', 0)) * 0.97,
                    "stop_loss_short": reversal_analysis.get('support_resistance_reversal', {}).get('enhanced_resistance_level', support_resistance.get('resistance_level', 0)) * 1.03,
                    "take_profit_long": reversal_analysis.get('support_resistance_reversal', {}).get('enhanced_resistance_level', support_resistance.get('resistance_level', 0)),
                    "take_profit_short": reversal_analysis.get('support_resistance_reversal', {}).get('enhanced_support_level', support_resistance.get('support_level', 0))
                },
                "timeframe_analysis": {
                    "short_term": f"{'ÏÉÅÏäπ' if signal_score > 0 else 'ÌïòÎùΩ' if signal_score < 0 else 'Ìö°Î≥¥'} ÏõÄÏßÅÏûÑ ÏòàÏÉÅ (Î∞òÏ†Ñ ÌôïÎ•†: {reversal_probability}%)",
                    "medium_term": f"Ï∂îÏÑ∏ {'ÏßÄÏÜç' if abs(signal_score) >= 2 else 'Ï†ÑÌôò'} Í∞ÄÎä•ÏÑ± ÎÜíÏùå",
                    "long_term": f"{'Í∞ïÏÑ∏' if signal_score >= 3 else 'ÏïΩÏÑ∏' if signal_score <= -3 else 'Ï§ëÎ¶Ω'} Í∏∞Ï°∞ Ïú†ÏßÄ"
                },
                "confidence": max(50, int(signal_strength + reversal_probability / 2)),  # Î∞òÏ†Ñ ÌôïÎ•†ÎèÑ Ïã†Î¢∞ÎèÑÏóê Î∞òÏòÅ
                "analysis_summary": f"Í∑úÏπô Í∏∞Î∞ò Ï¢ÖÌï© Î∂ÑÏÑù: {total_signals}Í∞ú ÏßÄÌëú Ï§ë ÏàúÏã†Ìò∏ {signal_score}Í∞ú ({'ÏÉÅÏäπ' if signal_score > 0 else 'ÌïòÎùΩ' if signal_score < 0 else 'Ï§ëÎ¶Ω'}), Î∞òÏ†Ñ ÌôïÎ•† {reversal_probability}%"
            }
            
            # Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
            result['analysis_metadata'] = {
                'analysis_type': 'rule_based_enhanced',
                'data_timestamp': datetime.now(timezone.utc).isoformat(),
                'model_used': 'rule_based_enhanced_fallback',
                'timeframe_used': self.get_timevalue,
                'reversal_signals_analyzed': True,
                'signal_score': signal_score,
                'total_signals': total_signals,
                'raw_data': indicators_data
            }
            
            return result
            
        except Exception as e:
            logger.error(f"Í∑úÏπô Í∏∞Î∞ò Ï¢ÖÌï© Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {e}")
            return {
                "overall_signal": "Hold",
                "error": str(e),
                "confidence": 0,
                "analysis_summary": f"Ï¢ÖÌï© Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(e)}"
            }
    
    async def analyze_technical_indicators(self, symbol='BTCUSDT', timeframe=None, limit=300) -> Dict:
        """Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù Î©îÏù∏ Ìï®Ïàò (ÎèôÏ†Å timeframe ÏÇ¨Ïö©)"""
        try:
            # timeframeÏù¥ NoneÏù¥Î©¥ TRADING_CONFIGÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
            if timeframe is None:
                timeframe = self.get_timevalue
                
            logger.info(f"Ï¢ÖÌï© Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù ÏãúÏûë - timeframe: {timeframe}")
            
            # 1. Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            df = self.get_chart_data(symbol, timeframe, limit)
            if df is None or df.empty:
                return {
                    "success": False,
                    "error": "Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Ïã§Ìå®",
                    "analysis_type": "enhanced_technical_analysis"
                }
            
            # 2. Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù Í≥ÑÏÇ∞
            processed_df, config_info = self.calculate_technical_indicators(df)
            
            # 3. ÌïµÏã¨ ÏßÄÌëú + Î∞òÏ†Ñ Ïã†Ìò∏ Ï∂îÏ∂ú
            indicators_data = self.extract_key_indicators(processed_df, config_info)
            
            if 'error' in indicators_data:
                return {
                    "success": False,
                    "error": indicators_data['error'],
                    "analysis_type": "enhanced_technical_analysis"
                }
            
            # 4. AI Ï¢ÖÌï© Î∂ÑÏÑù ÏàòÌñâ
            analysis_result = await self.analyze_with_ai(indicators_data)
            
            logger.info(f"Ï¢ÖÌï© Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù ÏôÑÎ£å - timeframe: {timeframe}")
            
            return {
                "success": True,
                "result": analysis_result,
                "analysis_type": "enhanced_technical_analysis"
            }
            
        except Exception as e:
            logger.error(f"Ï¢ÖÌï© Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑù Ï§ë Ïò§Î•ò: {e}")
            return {
                "success": False,
                "error": f"Î∂ÑÏÑù Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(e)}",
                "analysis_type": "enhanced_technical_analysis"
            }

# Ïô∏Î∂ÄÏóêÏÑú ÏÇ¨Ïö©Ìï† Ìï®Ïàò (Í∏∞Î≥∏Í∞íÏùÑ 1hÎ°ú Î≥ÄÍ≤Ω)
async def analyze_enhanced_technical_indicators(symbol='BTCUSDT', timeframe=None, limit=300) -> Dict:
    """Í∏∞Ïà†Ï†Å ÏßÄÌëú + Î∞òÏ†Ñ Î∂ÑÏÑùÏùÑ ÏàòÌñâÌïòÎäî Ìï®Ïàò (1ÏãúÍ∞ÑÎ¥â ÏµúÏ†ÅÌôî)"""
    analyzer = EnhancedTechnicalAnalyzer()
    return await analyzer.analyze_technical_indicators(symbol, timeframe, limit)

# ÌÖåÏä§Ìä∏Ïö© ÏΩîÎìú
if __name__ == "__main__":
    import asyncio
    
    async def test():
        result = await analyze_enhanced_technical_indicators()
        print(json.dumps(result, indent=2, ensure_ascii=False))
    
    asyncio.run(test())